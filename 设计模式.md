# 观察者模式

定义了对象之间一对多的关系。

分为主题（可观察者）和观察者：

①主题用一个共同的接口来更新观察者（添加观察者，删除观察者，通知观察者）。

②观察者实现update方法，用于主题通知观察者更新数据。

主题检测数据是否更新，若更新同步到观察者（类似订阅）

两者之间松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。

使用此模式时，你可以从被观察者处push或pull数据（一般是push），pull数据是为了满足不同观察者所需要的数据不一样的情况，由观察者决定接收的数据。（主题notifyObservers携带数据对象，传给update）

有多个观察者时，不可以依赖特定的通知次序。

JDK内置观察者模式在util包下的Observable类和Observer接口。

但Observable类会带来一些问题，继承类会带来一些局限性，如果一个主题同时拥有多个超类的特质，这时候复用性不强，java是不支持多继承的，必要时可以实现自己的Observable接口。

# 装饰者模式

动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

包含4块：抽象组件，具体组件，抽象装饰者，具体装饰者。

关系：具体组件继承自抽象组件，抽象装饰者继承自抽象组件，具体装饰者继承自抽象装饰者。（被装饰者和装饰者应该具有相同的类型）

装饰，就是包裹的关系，把被装饰者new出来得到引用1，然后用new装饰者1去装饰（引用1丢到装饰者的构造中）被装饰者的引用并得到一个新的引用2，引用2是已经被装饰者1装饰，然后new装饰者2去装饰引用2，以此类推。

奶茶加料为例，加不同的料累加金额。

抽象组件（奶茶）：包含成员变量描述和他的get方法、cost()。

具体组件（xxxxx奶茶）：重写cost（），设置描述，继承可以继承属性

抽象装饰者：getdescription抽象方法

具体装饰者（珍珠）：包含抽象组件的引用，重写cost时调用引用的cost并相加。